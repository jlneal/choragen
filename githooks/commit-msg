#!/bin/sh
set -eu

# Commit message validation hook
# Enforces semantic commit format and CR/FR traceability
# Format: type(scope): description [CR-ID|FR-ID]

COMMIT_MSG_FILE="$1"
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Allow merge commits and revert commits
if echo "$COMMIT_MSG" | grep -qE "^(Merge|Revert)"; then
  exit 0
fi

# Semantic commit pattern
# type(scope): description (min 10 chars after colon)
SEMANTIC_PATTERN='^(feat|fix|docs|test|refactor|chore|style|perf|ci|build|revert)(\([a-z0-9_-]+\))?: .{10,}'

# CR/FR reference pattern
CR_FR_PATTERN='(CR|FR)-[0-9]{8}-[0-9]{3}'

# Get the first line (subject)
SUBJECT=$(echo "$COMMIT_MSG" | head -n 1)

# Check semantic format
if ! echo "$SUBJECT" | grep -qE "$SEMANTIC_PATTERN"; then
  echo "" 1>&2
  echo "❌ Commit message must follow semantic format:" 1>&2
  echo "" 1>&2
  echo "   type(scope): description [CR-ID|FR-ID]" 1>&2
  echo "" 1>&2
  echo "   Types:" 1>&2
  echo "     feat     - New feature" 1>&2
  echo "     fix      - Bug fix" 1>&2
  echo "     docs     - Documentation changes" 1>&2
  echo "     refactor - Code refactoring" 1>&2
  echo "     test     - Test changes" 1>&2
  echo "     chore    - Build/tooling changes" 1>&2
  echo "     style    - Code style changes" 1>&2
  echo "     perf     - Performance improvements" 1>&2
  echo "     ci       - CI/CD changes" 1>&2
  echo "     build    - Build system changes" 1>&2
  echo "     revert   - Reverting previous commit" 1>&2
  echo "" 1>&2
  echo "   Examples:" 1>&2
  echo "     feat(core): add task chain validation [CR-20251206-001]" 1>&2
  echo "     fix(cli): resolve config parsing error [FR-20251206-001]" 1>&2
  echo "     chore(deps): update typescript to 5.3.0 (no CR required)" 1>&2
  echo "" 1>&2
  echo "   Your message:" 1>&2
  echo "     $SUBJECT" 1>&2
  echo "" 1>&2
  exit 1
fi

# Exempt specific chore types from CR/FR requirement
if echo "$SUBJECT" | grep -qE "^chore\((deps|format|tooling|metrics|planning)\):"; then
  # Will still validate scope matching below
  EXEMPT_FROM_CR=true
else
  EXEMPT_FROM_CR=false
fi

# Also exempt ci, build, revert types
if echo "$SUBJECT" | grep -qE "^(ci|build|revert)(\([^)]+\))?:"; then
  exit 0
fi

# Check for CR/FR reference (unless exempt)
if [ "$EXEMPT_FROM_CR" = "false" ] && ! echo "$COMMIT_MSG" | grep -qE "$CR_FR_PATTERN"; then
  echo "" 1>&2
  echo "❌ Commit must reference a CR or FR:" 1>&2
  echo "" 1>&2
  echo "   Format: type(scope): description [CR-YYYYMMDD-SEQ]" 1>&2
  echo "" 1>&2
  echo "   Examples:" 1>&2
  echo "     feat(core): add task chains [CR-20251206-001]" 1>&2
  echo "     fix(cli): resolve config error [FR-20251206-001]" 1>&2
  echo "" 1>&2
  echo "   Exempt types (no CR required):" 1>&2
  echo "     chore(deps): dependency updates" 1>&2
  echo "     chore(format): auto-formatting" 1>&2
  echo "     chore(tooling): build/CI changes" 1>&2
  echo "     chore(metrics): automated metrics updates" 1>&2
  echo "     chore(planning): creating/updating CR/FR docs" 1>&2
  echo "" 1>&2
  echo "   Create a request first:" 1>&2
  echo "     choragen cr:new <domain> <slug>" 1>&2
  echo "     choragen fr:new <domain> <slug>" 1>&2
  echo "" 1>&2
  echo "   Your message:" 1>&2
  echo "     $COMMIT_MSG" 1>&2
  echo "" 1>&2
  exit 1
fi

# Extract and validate CR/FR file exists and is in the correct status
CR_FR_ID=$(echo "$COMMIT_MSG" | grep -oE "$CR_FR_PATTERN" | head -n 1)

if [ -n "$CR_FR_ID" ]; then
  REQUEST_TYPE=$(echo "$CR_FR_ID" | sed 's/-.*//')
  if [ "$REQUEST_TYPE" = "CR" ]; then
    REQUEST_DIR="docs/requests/change-requests"
  else
    REQUEST_DIR="docs/requests/fix-requests"
  fi

  # Check if request exists and validate status (match files starting with request_id)
  if ls "$REQUEST_DIR/todo/$CR_FR_ID"*.md >/dev/null 2>&1; then
    echo "" 1>&2
    echo "❌ Cannot commit to $CR_FR_ID - request is still in todo/" 1>&2
    echo "" 1>&2
    echo "   Move the request to doing/ before committing:" 1>&2
    echo "     mv $REQUEST_DIR/todo/$CR_FR_ID*.md $REQUEST_DIR/doing/" 1>&2
    echo "" 1>&2
    echo "   This ensures work has been explicitly started." 1>&2
    echo "" 1>&2
    exit 1
  elif ls "$REQUEST_DIR/doing/$CR_FR_ID"*.md >/dev/null 2>&1; then
    # Valid: request is in progress
    :
  elif ls "$REQUEST_DIR/done/$CR_FR_ID"*.md >/dev/null 2>&1; then
    # Valid: adding commits to completed request (e.g., follow-up fixes)
    :
  elif find "$REQUEST_DIR/archive" -name "$CR_FR_ID*.md" 2>/dev/null | grep -q .; then
    # BLOCKING: archived requests should not receive new commits
    echo "" 1>&2
    echo "❌ Cannot commit to archived request $CR_FR_ID" 1>&2
    echo "" 1>&2
    echo "   Archived requests represent completed work and should not receive new commits." 1>&2
    echo "" 1>&2
    echo "   Options:" 1>&2
    echo "     1. Create a new CR/FR for this work:" 1>&2
    echo "        choragen cr:new <domain> <slug>" 1>&2
    echo "        choragen fr:new <domain> <slug>" 1>&2
    echo "     2. If this is a follow-up fix, reference the original in the new request" 1>&2
    echo "" 1>&2
    exit 1
  else
    echo "" 1>&2
    echo "❌ Request file not found for $CR_FR_ID" 1>&2
    echo "" 1>&2
    echo "   Expected in: $REQUEST_DIR/{doing,done}/$CR_FR_ID*.md" 1>&2
    echo "" 1>&2
    echo "   Create the request first:" 1>&2
    echo "     choragen cr:new <domain> <slug>" 1>&2
    echo "     choragen fr:new <domain> <slug>" 1>&2
    echo "" 1>&2
    exit 1
  fi
fi

# Validate scope matches changed files
# BLOCKING for exempt types (deps, format, tooling, metrics, planning) to prevent abuse
# WARNING for other types (flexibility for cross-cutting changes)
SCOPE=$(echo "$SUBJECT" | sed -n 's/^[a-z]*\(\([^)]*\)\):.*/\1/p')
if [ -n "$SCOPE" ]; then
  # Map scopes to expected file patterns
  case "$SCOPE" in
    core) EXPECTED_PATTERN="packages/core/" ;;
    cli) EXPECTED_PATTERN="packages/cli/" ;;
    contracts) EXPECTED_PATTERN="packages/contracts/" ;;
    eslint-plugin) EXPECTED_PATTERN="packages/eslint-plugin/" ;;
    test-utils) EXPECTED_PATTERN="packages/test-utils/" ;;
    deps) EXPECTED_PATTERN="package.json\|pnpm-lock" ;;
    tooling) EXPECTED_PATTERN="scripts/\|githooks/\|\.github/" ;;
    format) EXPECTED_PATTERN=".*" ;;  # Format can touch any file
    metrics) EXPECTED_PATTERN="metrics/\|\.json$" ;;
    docs) EXPECTED_PATTERN="^docs/\|\.md$" ;;
    planning) EXPECTED_PATTERN="docs/requests/\|docs/tasks/" ;;
    *) EXPECTED_PATTERN="" ;;
  esac

  if [ -n "$EXPECTED_PATTERN" ]; then
    # Get staged files
    STAGED_FILES=$(git diff --cached --name-only 2>/dev/null | tr '\n' ' ')
    if [ -n "$STAGED_FILES" ]; then
      # Check if any staged file matches the expected pattern
      if ! echo "$STAGED_FILES" | grep -qE "$EXPECTED_PATTERN"; then
        if [ "$EXEMPT_FROM_CR" = "true" ]; then
          # BLOCKING for exempt types - prevents abuse of CR-free commits
          echo "" 1>&2
          echo "❌ Scope mismatch for exempt commit type:" 1>&2
          echo "" 1>&2
          echo "   Commit scope '$SCOPE' does not match changed files." 1>&2
          echo "   Changed: $STAGED_FILES" 1>&2
          echo "   Expected pattern: $EXPECTED_PATTERN" 1>&2
          echo "" 1>&2
          echo "   Exempt types (deps, format, tooling, metrics, planning) MUST match their scope." 1>&2
          echo "   This prevents using exempt types to bypass CR/FR requirements." 1>&2
          echo "" 1>&2
          echo "   Options:" 1>&2
          echo "     1. Use a different commit type with a CR/FR reference" 1>&2
          echo "     2. Split the commit to match the scope" 1>&2
          echo "" 1>&2
          exit 1
        else
          # Warning only for non-exempt types
          echo "" 1>&2
          echo "⚠️  Scope mismatch warning:" 1>&2
          echo "   Commit scope '$SCOPE' may not match changed files." 1>&2
          echo "   Changed: $STAGED_FILES" 1>&2
          echo "   Expected pattern: $EXPECTED_PATTERN" 1>&2
          echo "" 1>&2
        fi
      fi
    fi
  fi
fi

exit 0
